<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>剑指Offer-栈、队列、链表和树 - Jijeng&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jijeng" /><meta name="description" content="这是剑指offer 系列四部曲中的第二部：栈、队列、链表和树。第一部关于字符串和数组，第三部是递归、回溯和动态规划， 最后一部分在这里。
" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.79.1 with theme even" />


<link rel="canonical" href="http://jijeng.github.io/post/offer_stack/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="剑指Offer-栈、队列、链表和树" />
<meta property="og:description" content="这是剑指offer 系列四部曲中的第二部：栈、队列、链表和树。第一部关于字符串和数组，第三部是递归、回溯和动态规划， 最后一部分在这里。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jijeng.github.io/post/offer_stack/" />
<meta property="article:published_time" content="2019-06-17T17:35:13+08:00" />
<meta property="article:modified_time" content="2019-06-17T17:35:13+08:00" />
<meta itemprop="name" content="剑指Offer-栈、队列、链表和树">
<meta itemprop="description" content="这是剑指offer 系列四部曲中的第二部：栈、队列、链表和树。第一部关于字符串和数组，第三部是递归、回溯和动态规划， 最后一部分在这里。">
<meta itemprop="datePublished" content="2019-06-17T17:35:13+08:00" />
<meta itemprop="dateModified" content="2019-06-17T17:35:13+08:00" />
<meta itemprop="wordCount" content="12693">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="剑指Offer-栈、队列、链表和树"/>
<meta name="twitter:description" content="这是剑指offer 系列四部曲中的第二部：栈、队列、链表和树。第一部关于字符串和数组，第三部是递归、回溯和动态规划， 最后一部分在这里。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Jijeng&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Jijeng&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">剑指Offer-栈、队列、链表和树</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-06-17 </span>
        
          <span class="more-meta"> 约 12693 字 </span>
          <span class="more-meta"> 预计阅读 26 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#重建二叉树-经典-多敲多背诵">重建二叉树 (经典， 多敲多背诵)</a></li>
            <li><a href="#用两个栈实现队列-经典">用两个栈实现队列 （经典）</a></li>
            <li><a href="#二叉树中和为某一值的路径">二叉树中和为某一值的路径**</a></li>
            <li><a href="#复杂链表的复制--比较经典的">复杂链表的复制  （比较经典的）</a></li>
            <li><a href="#二叉搜索树与双向链表">二叉搜索树与双向链表</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>这是剑指offer 系列四部曲中的第二部：栈、队列、链表和树。第一部关于<a href="https://jijeng.github.io/2019/05/17/%E5%89%91%E6%8C%87Offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84/">字符串和数组</a>，第三部是<a href="https://jijeng.github.io/2019/05/17/%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">递归、回溯和动态规划</a>， 最后一部分在<a href="https://jijeng.github.io/2019/05/17/%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96/">这里</a>。</p>
<p><strong>从尾到头打印链表</strong></p>
<blockquote>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
</blockquote>
<p>正向遍历之后，使用的是python 中list的特性， list[::-1] 这样进行输出的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span>
    <span class="c1"># += , -= 这个都是同一种类型的</span>
    <span class="k">def</span> <span class="nf">printListFromTailToHead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listNode</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="n">arraylist</span> <span class="o">=</span><span class="p">[]</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">listNode</span>
        <span class="k">while</span> <span class="n">head</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">arraylist</span> <span class="o">+=</span> <span class="p">[</span><span class="n">head</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
            <span class="c1"># 这个在这里等效于 arraylist.append(head.val)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">arraylist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
</code></pre></td></tr></table>
</div>
</div><p>在线编程中很少考察树的结构。所以就不写 main 函数版本了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 跟我的想法是一样的，首先遍历一遍，然后翻转，c++ 中的reverse 操作
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">printListFromTailToHead</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">head</span> <span class="o">=</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="重建二叉树-经典-多敲多背诵">重建二叉树 (经典， 多敲多背诵)</h3>
<blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<p>Tips: 递归，二叉树的题目大多数都是可以使用递归的思想进行解决，因为二叉树本身结构就是递归定义的。递归优点在于代码量比较少。从先序遍历中找出根节点，从中序遍历中找出左右子树</p>
<p>别怕，手写中如何重建二叉树，在代码中就是如何实现重建二叉树的。首先从前序list 中找到头结点，然后从中序队列中找见对应节点的index，那么前面的就是头结点的左子树，后面的就是右子树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回构造的TreeNode根节点</span>
    <span class="c1"># 需要理解在前序遍历中是先遍历左子树的，并且中序和前序中左子树的个数是不会变的</span>
    <span class="k">def</span> <span class="nf">reConstructBinaryTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">tin</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># 这个index 函数是需要记住的</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">tin</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># 这里也是需要修改的</span>
        <span class="c1"># pre 和 tin都是需要空出一个 root.value 的位置，只不过选择空的位置是不一样的</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tin</span><span class="p">[:</span><span class="n">index</span><span class="p">])</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reConstructBinaryTree</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">tin</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">root</span>
</code></pre></td></tr></table>
</div>
</div><p>优化点：
快速的在中序表中找见某个数的位置。使用hash 表实现。</p>
<p>时间复杂度是 $O(n)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for binary tree
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">;</span>
    
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">reConstructBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">_pre</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">_vin</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">preorder</span> <span class="o">=</span><span class="n">_pre</span><span class="p">,</span> <span class="n">inorder</span> <span class="o">=</span><span class="n">_vin</span><span class="p">;</span>
        <span class="c1">// 方便遍历
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">hash</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span><span class="n">i</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inorder</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">pl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ir</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pl</span> <span class="o">&gt;</span> <span class="n">pr</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
        
        <span class="k">auto</span> <span class="n">root</span> <span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">pl</span><span class="p">]);</span>
        
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span><span class="n">hash</span><span class="p">[</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">];</span>
        <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">pl</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">pl</span><span class="o">+</span><span class="n">k</span> <span class="o">-</span><span class="n">il</span><span class="p">,</span><span class="n">il</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 中序和前序对于 左子树的表示
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">right</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">pl</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">il</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ir</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span><span class="n">right</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
            
    <span class="p">}</span>      
    
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="用两个栈实现队列-经典">用两个栈实现队列 （经典）</h3>
<blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
</blockquote>
<p>Tips： 在python 中栈等同于使用list 实现。使用两个栈，意味着一个是push_stack 一个是pop_stack，使用两个栈的“后进先出”表示队列的先进先出（push and pop）
从语法上讲 ，if list1 ==[], 那么 list1 ==None, 这两个条件是可以交换判断的。（在list 中）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list1</span> <span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list2</span> <span class="o">=</span><span class="p">[]</span>
        
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># return </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">list1</span>  <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">list2</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list2</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list2</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">list1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list1</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">list2</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>c++ 实现。</p>
<p>···c++
class Solution
{
// 使用一个辅助栈 cache 进行pop() 的操作
public:
void push(int node) {</p>
<pre><code>    stack1.push(node);
}
void copy(stack&lt;int&gt; &amp;a, stack&lt;int&gt; &amp;b)
{
    while(a.size())
    {
        // 从一个栈到另一个栈的转换，这样就实现了 用栈表示队列
        // 访问机制是 先top() 访问，然后是 pop() 进行弹出
        b.push(a.top());
        a.pop();
    }
}

int pop() {
    copy(stack1, cache);
    int res =cache.top();
    
    cache.pop();
    copy(cache, stack1);
    return res;
    
}
</code></pre>
<p>private:
stack<int> stack1;
stack<int> cache;
};
···</p>
<p><strong>链表中倒数第k个结点</strong></p>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>Tips： 两种解法。一种是遍历存储到list 中，空间复杂度是O(N), 另外一种是两个指针p1，p2，距离相差k，当p2 到达链表尾部，p1 就在导数第k 个位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">尝试使用两个指针版本
</span><span class="s2">p1 p2 并且这种 length 在命名上是需要规范的, 并且这种指针操作，最好是拷贝出来进行操作
</span><span class="s2">不管怎么说，还是应该求解出来 length of listNode，这种才是正途
</span><span class="s2">可以使用两个指针，
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">FindKthToTail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">len1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">p1</span><span class="p">:</span>
            <span class="n">len1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">len1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">p1</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">p2</span>
</code></pre></td></tr></table>
</div>
</div><p>有两种思路，一种是正向遍历一遍，存储到list 中，然后使用list 性质，返回倒数第k 个结点，这个空间复杂度是 $O(n)$。还有一种思路是 遍历一遍得到链表的长度，然后倒数第 k 个结点就是正向数 n-k +1 个结点，再次遍历一遍就可以返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct ListNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct ListNode *next;
</span><span class="cm">	ListNode(int x) :
</span><span class="cm">			val(x), next(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">FindKthToTail</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">head</span> <span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="n">n</span><span class="o">++</span><span class="p">;</span> <span class="c1">//对于复杂的数据类型，直接使用 auto 这种方式进行定义就可以了
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span><span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// 这个是一个细节，但是牛客网上没有显示，如果 k 是超过总的长度那么怎么办
</span><span class="c1"></span>        
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">p</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>** 反转链表**</p>
<blockquote>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
</blockquote>
<p>Tips： 需要三个指针，cur，next_node, pre。</p>
<p>简单的链表的修改，最后新的表头就是一开始的尾节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class ListNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.val = x</span>
    <span class="c1">#         self.next = None</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    修改链表是需要三个指针的 pre, cur, next_node 
</span><span class="s2">    如果对三个指针名进行命名好了，那么这个就是成功的一般了， 这个不容易想到的是
</span><span class="s2">    设置pre =None ，这个是一个细节经验性的问题
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="c1"># 返回ListNode</span>
        <span class="k">def</span> <span class="nf">ReverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
            <span class="c1"># write code here</span>
            <span class="k">if</span> <span class="n">pHead</span> <span class="o">==</span><span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
                
            <span class="n">pre</span> <span class="o">=</span><span class="bp">None</span>
            <span class="n">cur</span> <span class="o">=</span><span class="n">pHead</span>
            
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="n">next_node</span> <span class="o">=</span><span class="n">cur</span><span class="o">.</span><span class="n">next</span>
                <span class="n">cur</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span><span class="n">pre</span>
                
                <span class="n">pre</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span><span class="n">cur</span><span class="p">,</span> <span class="n">next_node</span>
            <span class="k">return</span> <span class="n">pre</span>
</code></pre></td></tr></table>
</div>
</div><p>单链表中需要记录一个前驱结点。这个是考点所在。
这个是没有问题的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct ListNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct ListNode *next;
</span><span class="cm">	ListNode(int x) :
</span><span class="cm">			val(x), next(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">ReverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这个auto 的关键字 不能是在程序未知的情况下使用，应该是在“可知”的情况下使用
</span><span class="c1"></span>        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>
        
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span><span class="n">head</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">pre</span><span class="p">;</span>
            <span class="n">pre</span> <span class="o">=</span><span class="n">cur</span><span class="p">;</span>
            <span class="c1">// 这个时候需要遍历 cur 指针
</span><span class="c1"></span>            <span class="n">cur</span> <span class="o">=</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>合并两个排序的链表</strong></p>
<p>Tips： 归并排序中的“并” 操作，只不过由原来的list 操作到现在的 linkedlist 操作。</p>
<blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># def __init__(self, x):</span>
<span class="c1">#     self.val = x</span>
<span class="c1">#     self.next = None</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">就是在使用两个或者多个 index (p1 or p2) 遍历的时候，一个常见的错误就是忘记了不断更新index
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回合并后列表</span>
    <span class="k">def</span> <span class="nf">Merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead1</span><span class="p">,</span> <span class="n">pHead2</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="n">pHead1</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pHead2</span>
        <span class="k">if</span> <span class="n">pHead2</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pHead1</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">head1</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">pHead1</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">pHead2</span>
        <span class="k">while</span> <span class="n">p1</span> <span class="ow">and</span> <span class="n">p2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p1</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p2</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="k">if</span> <span class="n">p2</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="k">return</span> <span class="n">head1</span><span class="o">.</span><span class="n">next</span>


</code></pre></td></tr></table>
</div>
</div><p>归并排序的原理，合并两个有序的数组或者链表，使用线性的复杂度就可以使用。</p>
<p>归并排序中while 中使用的if else， 然后两个while 判断边界条件。 快排中 while 循环里面嵌套的是两个while 排序。这两个排序算法应该是碎觉都是十分熟悉的，怎么可以这样呢？每天都是要多复习的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct ListNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct ListNode *next;
</span><span class="cm">	ListNode(int x) :
</span><span class="cm">			val(x), next(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">Merge</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">p1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">p2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">dummy</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 虚拟结点
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span><span class="n">dummy</span><span class="p">;</span>
        
        <span class="k">while</span><span class="p">(</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="o">-&gt;</span> <span class="n">val</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">next</span><span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
                <span class="n">cur</span> <span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">p1</span> <span class="o">=</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">cur</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span><span class="n">p2</span><span class="p">;</span>
                <span class="n">cur</span> <span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">p2</span> <span class="o">=</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p1</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p2</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>树的子结构</strong></p>
<blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>递归定义，根节点是否相同，左右子树是否相同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class TreeNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.val = x</span>
    <span class="c1">#         self.left = None</span>
    <span class="c1">#         self.right = None</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    分成两部：首先寻找两个根节点的值是否相同；然后判断子树是否完全相同
</span><span class="s2">    subTree 这个函数就是判断子树是否完全相同的，所以函数的功能一定要搞好
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">HasSubtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot1</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">result</span> <span class="o">=</span><span class="bp">False</span>
            
            <span class="k">if</span> <span class="n">pRoot1</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span><span class="n">pRoot2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subTree</span><span class="p">(</span><span class="n">pRoot1</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">HasSubtree</span><span class="p">(</span><span class="n">pRoot1</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">pRoot2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        
        <span class="k">def</span> <span class="nf">subTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">,</span> <span class="n">root2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">root1</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span><span class="n">root2</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTree</span><span class="p">(</span><span class="n">root1</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTree</span><span class="p">(</span><span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
</code></pre></td></tr></table>
</div>
</div><p>从字符串的匹配 扩展了 树的匹配</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct TreeNode *left;
</span><span class="cm">	struct TreeNode *right;
</span><span class="cm">	TreeNode(int x) :
</span><span class="cm">			val(x), left(NULL), right(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">HasSubtree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">root1</span> <span class="o">||</span> <span class="o">!</span><span class="n">root2</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">// 这个是寻找根节点的过程
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">isPart</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">root2</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">HasSubtree</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="p">)</span> <span class="o">||</span> <span class="n">HasSubtree</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="nf">isPart</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 找到一个根节点相同，然后不断往下遍历的过程
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p1</span> <span class="o">||</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">-&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">isPart</span><span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isPart</span><span class="p">(</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// 先是遍历找相同的根节点，
</span><span class="c1">// 如果相同的话，接着去找相应的左右子树是否相同
</span></code></pre></td></tr></table>
</div>
</div><p>第二遍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct TreeNode *left;
</span><span class="cm">	struct TreeNode *right;
</span><span class="cm">	TreeNode(int x) :
</span><span class="cm">			val(x), left(NULL), right(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//先是遍历根节点，然后再遍历对应根节点的左右结点
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">HasSubtree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">root1</span> <span class="o">||</span> <span class="o">!</span> <span class="n">root2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">isSub</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">root2</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="nf">HasSubtree</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="p">)</span> <span class="o">||</span> <span class="n">HasSubtree</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="nf">isSub</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">root2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">root1</span> <span class="o">||</span> <span class="n">root1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">isSub</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSub</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>二叉树的镜像</strong></p>
<blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
</blockquote>
<p>Tips：求解二叉树镜像，A 的左子树对应着B 的右子树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class TreeNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.val = x</span>
    <span class="c1">#         self.left = None</span>
    <span class="c1">#         self.right = None</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    就是在某个左（右）子树是None 的情况下，这个也是可以进行交换的，结束的标志应该是根节点是否为空
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="c1"># 返回镜像树的根节点</span>
        <span class="k">def</span> <span class="nf">Mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
            <span class="c1"># write code here</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Mirror</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Mirror</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">root</span>
            
</code></pre></td></tr></table>
</div>
</div><p>任意一个结点的左右子树都发生互换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct TreeNode *left;
</span><span class="cm">	struct TreeNode *right;
</span><span class="cm">	TreeNode(int x) :
</span><span class="cm">			val(x), left(NULL), right(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 特点，任意一个结点，左右子树都是相反的
</span><span class="c1"></span>    <span class="c1">// 互换的过程应该是 从下到上进行的，所以是不断的进行递归，然后最后一个是 swap() 操作
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">Mirror</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">pRoot</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span> <span class="n">pRoot</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="n">Mirror</span><span class="p">(</span><span class="n">pRoot</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
        <span class="n">Mirror</span><span class="p">(</span><span class="n">pRoot</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">pRoot</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">pRoot</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
        
        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>包含min函数的栈</strong></p>
<blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
</blockquote>
<p>Tips: 这个跟“使用两个栈表示队列” 是差不多的，就是单独使用一个list 存储min 函数调用的一个列表，这样的话能达到时间复杂度是 O(1).</p>
<p>在原来的基础上，stack 的基础上，使用新的 min_stack 满足这个需求，同样，原来的 push pop 这种操作还是不能少的。所以是维护了两个 list（normal_list, min_list），但是当normal_list pop() 出来的时候，这个min_list 和其pop 出来的不一定是相同的值。（我感觉）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">这个栈中最小的元素是变化的，好好理解一下，如果弹出了一个比较大的元素，那么栈中最小的元素是不变的
</span><span class="s2">所含元素的最小元素
</span><span class="s2">top() and min() 操作是不需要删除元素的， pop 是删除了元素
</span><span class="s2">
</span><span class="s2">&#34;&#34;&#34;</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span> <span class="c1"># 好多思想都是基于之前的结果进行求解</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># write code here</span>

    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># write code here</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    
    <span class="c1">// 关键在于维护两个 stack
</span><span class="c1"></span>    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">,</span> <span class="n">stk_min</span><span class="p">;</span>
    
    <span class="c1">// 这个是最重要的function了
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="c1">//if( stk_min.size()) value = value&lt; stk_min.top() ? value, stk_min.top();
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">stk_min</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">value</span> <span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">stk_min</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
        <span class="n">stk_min</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">stk_min</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">top</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">min</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">stk_min</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>栈的压入、弹出序列</strong></p>
<blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>Tips:  使用一个list 来模拟压入和弹出过程，遍历弹出序列popV，如果结束，那么return True。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">IsPopOrder</span><span class="p">(</span> <span class="n">pushV</span><span class="p">,</span> <span class="n">popV</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pushV</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">tmp</span> <span class="o">=</span><span class="p">[]</span>
    <span class="k">while</span> <span class="n">popV</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">and</span> <span class="n">popV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">popV</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">pushV</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pushV</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

</code></pre></td></tr></table>
</div>
</div><p>是一种模拟题，因为选择是唯一的，对应某种情况，那么操作是一定的。使用一个 栈模拟整个操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;stack&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">isPopOrder</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pushV</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">popV</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pushV</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">popV</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span>  <span class="nb">false</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">u</span><span class="p">:</span> <span class="n">pushV</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="n">popV</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="c1">//cout&lt;&lt; stk.top()&lt;&lt;&#34; &#34;&lt;&lt; endl;
</span><span class="c1"></span>            <span class="c1">//cout&lt;&lt; stk.top() &lt;&lt;&#34; &#34;&lt;&lt; i&lt;&lt; endl;
</span><span class="c1"></span>            <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">i</span> <span class="o">++</span><span class="p">;</span>

        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pushV</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">popV</span><span class="o">=</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">isPopOrder</span><span class="p">(</span><span class="n">pushV</span><span class="p">,</span> <span class="n">popV</span><span class="p">)</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>从上往下打印二叉树</strong></p>
<blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>Tips： 层次遍历，遍历根节点之后加入左右结点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回从上到下每个节点值列表，例：[1,2,3]</span>
    <span class="c1"># 层序遍历二叉树， 这个跟数据结构 队列有类似的</span>
    <span class="c1"># nodes 装上结点，然后vlaues 装上数值</span>
    <span class="k">def</span> <span class="nf">PrintFromTopToBottom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">nodes</span> <span class="o">=</span><span class="p">[]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>
</code></pre></td></tr></table>
</div>
</div><p>好的方法，就是枚举出来的方法，大家都是这个是经典的算法，但是这种一开始的 intuition，这种 idea 是怎么出来的。一般是没有人去怎么描述的。所以，是要追根溯源的。对于一个问题，一共有哪些方法是在这个范畴，哪些是可以用的。排除一个认为不可能的，然后就开始尝试。</p>
<p>题目要求是一种层序遍历。对于树的遍历是有深搜 和宽搜两种方式，发现神搜不合适，宽搜正好，所以使用宽度优先搜索。对于宽度优先搜索是需要维护一个队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct TreeNode *left;
</span><span class="cm">	struct TreeNode *right;
</span><span class="cm">	TreeNode(int x) :
</span><span class="cm">			val(x), left(NULL), right(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 队列中的操作 queue, front() 访问， pop() 删除
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">PrintFromTopToBottom</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
        <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> 
        <span class="k">while</span><span class="p">(</span><span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span><span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>层序遍历，把二叉树打印成多行（这个是输出是多行，而不是一行）
c++ 实现。重点使用了 nullptr 指针进行了尾部的标记。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">    int val;
</span><span class="cm">    struct TreeNode *left;
</span><span class="cm">    struct TreeNode *right;
</span><span class="cm">    TreeNode(int x) :
</span><span class="cm">            val(x), left(NULL), right(NULL) {
</span><span class="cm">    }
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 打印成多行，所以在每行打印的时候，每行的最后可以加入一个 nullptr 作为结束
</span><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Print</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">pRoot</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">pRoot</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
            <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
            <span class="c1">//判断 queue 是否为空的条件
</span><span class="c1"></span>            <span class="k">while</span><span class="p">(</span><span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span><span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">t</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
                    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
                    <span class="n">level</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="p">}</span>
    
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>二叉搜索树的后序遍历序列</strong></p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>Tips：二叉搜索树，按照中序遍历的话，就是一个排序的二叉树，根节点大于左子树，右子树大于根节点。后序遍历序列中最后一个是根节点，小于根节点是左子树，大于根节点的是右子树，这样进行判断。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 后序遍历结果， 最后一个是根节点，这个是递归的思想</span>
    <span class="c1"># 二叉搜索树， 左子树小于根节点，右子树大于根节点</span>
    <span class="k">def</span> <span class="nf">VerifySquenceOfBST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">sequence</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></td></tr></table>
</div>
</div><p>这个边界条件也是比较好进行处理的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 是判断题，需要返回的true or false 两种选择 
</span><span class="c1"></span>    <span class="c1">//  搜索二叉树 ，左子树小于根节点， 右子树大于根节点，后序遍历是左子树 右子树 然后是根节点
</span><span class="c1"></span>    <span class="c1">// 那么最后一个是根节点，如果值小于根节点，那么就是该根结点的左子树；否则是该根节点的右子树，递归的进行判断
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seq</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">VerifySquenceOfBST</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sequence</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">sequence</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">seq</span> <span class="o">=</span><span class="n">sequence</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span><span class="n">seq</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
        
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span><span class="n">l</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">k</span><span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">)</span> <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">r</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉树中和为某一值的路径">二叉树中和为某一值的路径**</h3>
<blockquote>
<p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
</blockquote>
<p>Tips： 树的遍历，深度优先算法（dfs）</p>
<p>这个是非常典型的 dfs，是值得掌握的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回二维列表，内部每个列表表示找到的路径</span>
    <span class="c1"># 深度优先 dfs() 这样的一个算法</span>
    <span class="k">def</span> <span class="nf">FindPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">expectNumber</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">expectNumber</span>

        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">],</span> <span class="n">paths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span>


<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
        <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">],</span> <span class="n">paths</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">],</span> <span class="n">paths</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div><p>c++ 写法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct TreeNode *left;
</span><span class="cm">	struct TreeNode *right;
</span><span class="cm">	TreeNode(int x) :
</span><span class="cm">			val(x), left(NULL), right(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="c1">// 深度优先的遍历
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">FindPath</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span><span class="kt">int</span> <span class="n">expectNumber</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span> <span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">expectNumber</span><span class="p">);</span> <span class="c1">// 使用 sum -val 可以减少一个变量的使用
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        
        <span class="n">sum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">-&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">val</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sum</span><span class="p">)</span> <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">// 这个是 c++ 中 vector() 的操作 就是pop_back() 是没有其他的参数的
</span><span class="c1"></span>        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="复杂链表的复制--比较经典的">复杂链表的复制  （比较经典的）</h3>
<blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<p>Tips: 先是在原来的链表上进行了相同结点的copy和next 指针的指向，然后是random 指针的指向，最后是将原始链表和copy 的链表进行分离。</p>
<p>思路，是先复制节点和 next 指针，然后再遍历一遍复制 random 指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class RandomListNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.label = x</span>
    <span class="c1">#         self.next = None</span>
    <span class="c1">#         self.random = None</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="c1"># 返回 RandomListNode</span>
        <span class="c1"># 首先是结点的复制和 next 指针的连接， 然后是random 指针的连接，最后是选择出复制的结点</span>
    <span class="k">def</span> <span class="nf">Clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pHead</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clone_nodes</span><span class="p">(</span><span class="n">pHead</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect_nodes</span><span class="p">(</span><span class="n">pHead</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_nodes</span><span class="p">(</span><span class="n">pHead</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">clone_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">cloned</span> <span class="o">=</span> <span class="n">RandomListNode</span><span class="p">(</span><span class="n">head</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">cloned</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cloned</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cloned</span><span class="o">.</span><span class="n">next</span>
    <span class="k">def</span> <span class="nf">connect_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">cloned</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>

            <span class="k">if</span> <span class="n">head</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
                <span class="n">cloned</span><span class="o">.</span><span class="n">random</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">cloned</span><span class="o">.</span><span class="n">next</span>
    <span class="k">def</span> <span class="nf">select_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">cloned</span> <span class="o">=</span><span class="n">cloned_head</span> <span class="o">=</span><span class="bp">None</span>
        <span class="c1"># 这个if 的作用是为了保存一个 cloned_head的结点，</span>
        <span class="c1"># 一定要从这个功能出发</span>
        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">cloned</span> <span class="o">=</span><span class="n">cloned_head</span> <span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span><span class="n">cloned</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">cloned</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>
            <span class="n">cloned</span> <span class="o">=</span><span class="n">cloned</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span><span class="n">cloned</span><span class="o">.</span><span class="n">next</span>
            <span class="n">head</span> <span class="o">=</span><span class="n">head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">cloned_head</span>
</code></pre></td></tr></table>
</div>
</div><p>思路是完全正确的，但是不知道为什么在 牛客上，这个case 通过率是0.真的是太难了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct RandomListNode {
</span><span class="cm">    int label;
</span><span class="cm">    struct RandomListNode *next, *random;
</span><span class="cm">    RandomListNode(int x) :
</span><span class="cm">            label(x), next(NULL), random(NULL) {
</span><span class="cm">    }
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 分成三步骤，首先是复制结点插入到原来的链表中，然后处理random指针，最后是将链表挑选出来
</span><span class="c1"></span>    <span class="n">RandomListNode</span><span class="o">*</span> <span class="n">Clone</span><span class="p">(</span><span class="n">RandomListNode</span><span class="o">*</span> <span class="n">pHead</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 加入一个node 是需要操作两个指针的
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">pHead</span><span class="p">;</span> <span class="n">p</span><span class="p">;)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">np</span> <span class="o">=</span><span class="k">new</span> <span class="n">RandomListNode</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">np</span><span class="p">;</span>
            <span class="n">np</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">next</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 处理random指针
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">pHead</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">random</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">-&gt;</span><span class="n">random</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">random</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">auto</span> <span class="n">dummy</span> <span class="o">=</span><span class="k">new</span> <span class="n">RandomListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span><span class="n">dummy</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">pHead</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span><span class="n">p</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cur</span> <span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="c1">//p =p-&gt;next;
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉搜索树与双向链表">二叉搜索树与双向链表</h3>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<p>Tips：中序遍历二叉搜索树就是一种排序的树的结点，然后树的左右指针可以作为链表中的指向使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class TreeNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.val = x</span>
    <span class="c1">#         self.left = None</span>
    <span class="c1">#         self.right = None</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="c1"># 使用的树的结构 表示一种双向链表</span>
        <span class="c1"># 二叉搜索树 ，左子树小于根节点，右子树大于根节点</span>
        <span class="c1"># 中序遍历得到就是一种排好序的结构</span>
        <span class="c1"># 只能调整树中结点指针的指向</span>
        <span class="k">def</span> <span class="nf">Convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRootOfTree</span><span class="p">):</span>
            <span class="c1"># write code here</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pRootOfTree</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">pRootOfTree</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">helper</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># 这个返回值也是比较鬼畜呀， 就是需要这样返回</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">helper</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这个代码长度有点多，所以之后再看。
<a href="https://www.acwing.com/video/173/">讲解链接</a></p>
<ul>
<li>两个链表的第一个公共结点</li>
</ul>
<blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>Tips：就是一个 m*n 的问题（m，n 分别代表两个链表的长度）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 两个指针指向的是 一个结点，一个内存的两个指向</span>
    <span class="c1"># 将可能不同长度的两个链表转换成相同长度的两个链表的比较，使用</span>
    <span class="k">def</span> <span class="nf">FindFirstCommonNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead1</span><span class="p">,</span> <span class="n">pHead2</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pHead1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">pHead2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">pHead1</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">pHead2</span>
        <span class="k">while</span> <span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">:</span>
            <span class="c1"># 这个p1 只能指向了最后一个结点，但最后一个节点不一定相同</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">pHead2</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">p1</span> <span class="k">else</span> <span class="n">p1</span><span class="o">.</span><span class="n">next</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">pHead1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">p2</span> <span class="k">else</span> <span class="n">p2</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="n">p1</span>
</code></pre></td></tr></table>
</div>
</div><p>该题目有一种比较巧妙的做法，如果一个指针走完之后，指向另一个list 的开头；同理，另一个指针也是可以这样进行操作。如果是可以相遇的，那么一定最后可以相遇，因为走过的路径是一样的长度的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct ListNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct ListNode *next;
</span><span class="cm">	ListNode(int x) :
</span><span class="cm">			val(x), next(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">FindFirstCommonNode</span><span class="p">(</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span><span class="n">head1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span><span class="n">head2</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="n">p1</span> <span class="o">=</span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">p1</span> <span class="o">=</span><span class="n">head2</span><span class="p">;</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="n">p2</span> <span class="o">=</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">p2</span> <span class="o">=</span><span class="n">head1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 这个时候p1 和p2 已经相等了
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">p1</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>二叉树的深度</li>
</ul>
<blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>Tips：递归，相比于二叉树的路径，这个只是返回一个数值就行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    分别求解 左右子树的深度，然后max(left, right) 这样的操作
</span><span class="s2">    &#34;&#34;&#34;</span>

    <span class="k">def</span> <span class="nf">TreeDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TreeDepth</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TreeDepth</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># 这个return 是最后执行一次的，然后上面那个都是不断的在进行递归加深</span>
        <span class="c1"># 这个 left right 已经完成了，最后的效果只是 返回 max(left, right) 这样子</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> 
</code></pre></td></tr></table>
</div>
</div><p>一般二叉树的问题都是可以使用递归求解的，因为树本身就是使用递归进行定义的。
思路：如果左右子树不为空，那么就返回左右子树深度 +1。这个就是递归的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">	int val;
</span><span class="cm">	struct TreeNode *left;
</span><span class="cm">	struct TreeNode *right;
</span><span class="cm">	TreeNode(int x) :
</span><span class="cm">			val(x), left(NULL), right(NULL) {
</span><span class="cm">	}
</span><span class="cm">};*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">TreeDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">TreeDepth</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">),</span> <span class="n">TreeDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">))</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>平衡二叉树</li>
</ul>
<blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<p>Tips： 左右子树的深度差最大不超过1。两个递归，一个是计算树的深度的递归，一个是判断左右子树是否是平衡二叉树的递归。</p>
<p>对于平衡二叉树的第一反应，应该想到这个是二叉搜索树的一种改进。为了防止出现链表式的二叉搜索树，平衡二叉树限制了左右子树的相差的高度。通过调整左右子树，保持了二叉搜索树的性质。 直观上讲不是很偏（没有偏向一边）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class TreeNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.val = x</span>
    <span class="c1">#         self.left = None</span>
    <span class="c1">#         self.right = None</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="c1"># 递归常见的都会有两个return 跳出条件，一个是异常的条件，一个是正确的返回</span>
        <span class="k">def</span> <span class="nf">get_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">left</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span>
        
    <span class="k">def</span> <span class="nf">IsBalanced_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        
        <span class="n">left</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_depth</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">left</span><span class="o">-</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">IsBalanced_Solution</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">IsBalanced_Solution</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        
</code></pre></td></tr></table>
</div>
</div><p>在求解 树的深度的过程中，判断是否是平衡二叉树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 本问题求解的过程中使用到了 求解树的深度代码
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">ans</span> <span class="o">=</span><span class="nb">true</span><span class="p">;</span> 
    <span class="kt">bool</span> <span class="nf">IsBalanced_Solution</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">pRoot</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 求解深度的过程
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="p">),</span> <span class="n">right</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="n">ans</span> <span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        
    <span class="p">}</span>
    
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>链表中环的入口结点</li>
</ul>
<blockquote>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
</blockquote>
<p>Tips： 两个快慢指针，开指针在环内相遇慢指针。（两个指针一个需要再环外，一个在环内，然后同样的速度走，最后才能相遇）重置快指针到头结点，两个指针相同速度，当再次相遇时候，那就是入口结点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">    <span class="c1"># -*- coding:utf-8 -*-</span>
    <span class="c1"># class ListNode:</span>
    <span class="c1">#     def __init__(self, x):</span>
    <span class="c1">#         self.val = x</span>
    <span class="c1">#         self.next = None</span>
    <span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
        <span class="c1"># 现在长个记性吧，在使用next 这样的时候 要先判断这个是不是存在的</span>
        <span class="k">def</span> <span class="nf">EntryNodeOfLoop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
            <span class="c1"># write code here</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pHead</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">pHead</span><span class="o">.</span><span class="n">next</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">pHead</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">twoTimes</span> <span class="o">=</span><span class="n">pHead</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
            <span class="n">oneTime</span> <span class="o">=</span><span class="n">pHead</span><span class="o">.</span><span class="n">next</span>
            <span class="k">while</span> <span class="n">twoTimes</span> <span class="o">!=</span> <span class="n">oneTime</span><span class="p">:</span>
                <span class="n">twoTimes</span> <span class="o">=</span><span class="n">twoTimes</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">next</span>
                <span class="n">oneTime</span> <span class="o">=</span><span class="n">oneTime</span><span class="o">.</span><span class="n">next</span>
            <span class="n">twoTimes</span> <span class="o">=</span><span class="n">pHead</span>
            <span class="k">while</span> <span class="n">twoTimes</span> <span class="o">!=</span> <span class="n">oneTime</span><span class="p">:</span>
                <span class="n">twoTimes</span> <span class="o">=</span><span class="n">twoTimes</span><span class="o">.</span><span class="n">next</span>
                <span class="n">oneTime</span> <span class="o">=</span><span class="n">oneTime</span><span class="o">.</span><span class="n">next</span>
            <span class="k">return</span> <span class="n">twoTimes</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// c++ 中 单链表的定义
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">ListNode</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">){}</span> <span class="c1">// 构造函数
</span><span class="c1"></span>    
<span class="p">};</span>

<span class="n">ListNode</span> <span class="o">*</span><span class="nf">entryNodeOfLoop</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span><span class="n">head</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span><span class="n">head</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span><span class="n">j</span> <span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="p">)</span> <span class="n">j</span><span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">i</span> <span class="o">=</span><span class="n">head</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">i</span> <span class="o">=</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">j</span> <span class="o">=</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p4</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">head</span> <span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p1</span><span class="p">,</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p2</span><span class="p">,</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p3</span><span class="p">,</span> <span class="n">p3</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p4</span><span class="p">;</span>
    <span class="n">p4</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p1</span><span class="p">;</span>
    <span class="c1">//cout&lt;&lt; head-&gt;val&lt;&lt;endl;
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span><span class="n">entryNodeOfLoop</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><ul>
<li>删除链表中重复的结点</li>
</ul>
<blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class ListNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.next = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteDuplication</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pHead</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">head</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">pHead</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">curr</span> <span class="ow">and</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
            <span class="c1"># val =curr.val</span>
            <span class="c1"># 这个条件比较简单，所以可以放到前面</span>
            <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 这个条件 curr 还是需要注意一下的</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span>
                <span class="c1"># python 中 condition1 and condition2 这种是有先后顺序的</span>
                <span class="c1"># 可能是存在短路现象的， 如果 curr 不成立，那么后面的是不会执行的 </span>
                <span class="c1"># 草拟</span>
                <span class="k">while</span> <span class="n">curr</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">==</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
                <span class="n">last</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="n">next</span>
</code></pre></td></tr></table>
</div>
</div><p>凡是可能把头结点删掉的问题，一般来说我们都是会定义一个虚拟头结点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">ListNode</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">){}</span>
<span class="p">};</span>
<span class="c1">// 这个是排序之后的链表，那么可以把原来的list 看成一段一段， 使用p 和q 两个指针分别指向的两段的开头
</span><span class="c1">// 对于可能删除头结点的，一般使用虚拟结点，简化处理的情况
</span><span class="c1"></span><span class="n">ListNode</span> <span class="o">*</span> <span class="nf">deleteDumplication</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">dummy</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">head</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">dummy</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">q</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="n">q</span> <span class="o">=</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="n">p</span>  <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">q</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">p3</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">p22</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">p33</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">auto</span>  <span class="n">p4</span> <span class="o">=</span><span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p2</span><span class="p">,</span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p22</span><span class="p">,</span> <span class="n">p22</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p3</span><span class="p">,</span> <span class="n">p3</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p33</span><span class="p">,</span> <span class="n">p33</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">p4</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span><span class="n">deleteDumplication</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>** 在 $O(1)时间删除链表结点$**</p>
<p>给定单向链表的一个节点指针，定义一个函数在 $O(1)$ 时间删除该结点。</p>
<p><a href="https://www.acwing.com/problem/content/85/">题目</a>
<a href="https://www.acwing.com/video/152/">视频讲解</a></p>
<p>一般删除一个节点需要知道其前驱结点，但是还有另外一种做法，就是通过下一个结点覆盖到本结点，然后删除下一个结点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>二叉树的下一个结点</li>
</ul>
<blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>Tips：中序遍历的下一个结点，如果存在右节点，那么下一个结点是右节点最左边的一个点；如果该结点是其父节点的左结点，那么下一节点是其父节点，否则一直回溯。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeLinkNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="c1">#         self.next = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># https://blog.csdn.net/fuxuemingzhu/article/details/79723819 </span>
    <span class="c1"># 这个是求解中序遍历中某个结点的下一个结点</span>
    <span class="c1"># 这pNode 就是一个普通的结点</span>
    <span class="k">def</span> <span class="nf">GetNext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pNode</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="c1"># 如果存在右结点</span>
        <span class="k">if</span> <span class="n">pNode</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">.</span><span class="n">right</span>
            <span class="k">while</span> <span class="n">pNode</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">.</span><span class="n">left</span>
            <span class="k">return</span> <span class="n">pNode</span>
        <span class="c1"># 如果是父节点的左子树</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 这里使用 pNode.next 表示父节点</span>
            <span class="k">while</span> <span class="n">pNode</span><span class="o">.</span><span class="n">next</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pNode</span> <span class="o">==</span> <span class="n">pNode</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">pNode</span><span class="o">.</span><span class="n">next</span>
                <span class="c1"># 这个是右结点</span>
                <span class="n">pNode</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">.</span><span class="n">next</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>对称的二叉树</li>
</ul>
<blockquote>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<p>Tips: 判断镜像和递归生成进行还是不太一样的哈。递归判断，根节点相同，然后左右子树是否是对称。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="c1"># 镜像的概念 和递归</span>
    <span class="c1"># isSame() 这个就是判断两个子树是否镜像的操作</span>
    
    <span class="k">def</span> <span class="nf">isSame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="c1"># 好好思考 下面这两个跳出条件为什么是不合适的</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">and</span> <span class="n">q</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">isSymmetrical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="c1"># 最开始的条件 如果都是 none 那么这个是对称的</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">pRoot</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">pRoot</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSame</span><span class="p">(</span><span class="n">pRoot</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">pRoot</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>除了根结点，左右两个子树都是对称的。对称二叉树，非对称二叉树（权值不对称），非对称二叉树（结构不对称）。所以这个是对称或者镜像是有两个维度的，结构和内容。</p>
<p>c++ 实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">struct TreeNode {
</span><span class="cm">    int val;
</span><span class="cm">    struct TreeNode *left;
</span><span class="cm">    struct TreeNode *right;
</span><span class="cm">    TreeNode(int x) :
</span><span class="cm">            val(x), left(NULL), right(NULL) {
</span><span class="cm">    }
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">isSymmetrical</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 在定义的时候，不要使用auto 了，使用具体的类型
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 如果有空的情况下，只有两者都为空，那么返回的是true，否则是false
</span><span class="c1"></span>        <span class="c1">// 这种简洁的代码 就应该记住
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="o">!</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        
    <span class="p">}</span>

<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>按之字形顺序打印二叉树</li>
</ul>
<p>对于二叉树的层序遍历有三种不同的题型。</p>
<ol>
<li>不分行的层序遍历</li>
<li>不分行的层序遍历（偶数行是从左到右，奇数行是从右到左）</li>
<li>分行的层序遍历（每打印一行就另起一行）</li>
</ol>
<blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p>Tips：层序遍历的升级版，有两种思路，一种是使用单独 stack (list) 的思想存储偶数层数，一种是先按照原先层序遍历的思想，最后对于偶数的结果进行“翻转” 处理。选择后者，因为代码上比较简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 层序遍历 + 偶数翻转</span>
    <span class="c1"># https://blog.csdn.net/fuxuemingzhu/article/details/79724959</span>
    <span class="k">def</span> <span class="nf">level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        root: the root of tree
</span><span class="s2">        level: 
</span><span class="s2">        res: result
</span><span class="s2">        &#34;&#34;&#34;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="n">level</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="n">res</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">(</span><span class="n">pRoot</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">level</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></td></tr></table>
</div>
</div><p>按照之字形顺序打印二叉树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm"> struct TreeNode {
</span><span class="cm"> int val;
</span><span class="cm"> struct TreeNode *left;
</span><span class="cm"> struct TreeNode *right;
</span><span class="cm"> TreeNode(int x) :
</span><span class="cm"> val(x), left(NULL), right(NULL) {
</span><span class="cm"> }
</span><span class="cm"> };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Print</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">pRoot</span><span class="p">)</span> <span class="p">{</span>
        
        
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">pRoot</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
        <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
        <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">zigzag</span> <span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="c1">//判断 queue 是否为空的条件
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span><span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">t</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">zigzag</span><span class="p">)</span> <span class="n">reverse</span><span class="p">(</span><span class="n">level</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">level</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
                <span class="n">zigzag</span> <span class="o">=!</span><span class="n">zigzag</span><span class="p">;</span> <span class="c1">// 这个取反的操作
</span><span class="c1"></span>                <span class="n">level</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">//因为使用的是push back 操作，所以得clear() 操作
</span><span class="c1"></span>                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


</code></pre></td></tr></table>
</div>
</div><ul>
<li>把二叉树打印成多行</li>
</ul>
<blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<p>Tips: 和上一个题目类似，在遍历二叉树的时候，关键是加入了 [level] 层数这种信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 返回二维列表[[1,2],[4,5]]</span>
    <span class="k">def</span> <span class="nf">level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="c1"># 你这里也没有说要返回值的意思呀，这个直接是 return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

        <span class="n">res</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="c1"># res[level] =self.level(root.right, level+1, res)</span>
            <span class="c1"># 因为这个是 传的值，所以不需要使用返回值的</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">(</span><span class="n">pRoot</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/binary-tree-right-side-view/submissions/">Binary Tree Right Side View</a></p>
<p>是层序遍历，核心是理解使用 <code>nullptr</code> 作为一层结束的标志，所以当弹出的是<code>nullptr</code> 的时候，就应该去处理一层的遍历结果，不管是reverse 还是只是取最后一个。并且这个时候是需要加上一个<code>nullptr</code>，表示当前层的结束。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">queue</span> <span class="o">&lt;</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
        <span class="n">vector</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">// 因为这里使用 nullptr 作为一层的结束，所以当前的t 为空的时候，最重要的是将 level.back() 加到 res中，然后加上 nullptr
</span><span class="c1"></span>            <span class="c1">// 否则的话是不断地 push
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">level</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
                <span class="n">level</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">level</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>序列化二叉树</li>
</ul>
<blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
</blockquote>
<p>Tips：序列号和反序列化只是一种约定的存储的形式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    序列化就是从树结构 转成字符串的结构；反之，也是成立的。 使用先序遍历的方法。
</span><span class="s2">    https://suixinblog.cn/2019/03/target-offer-serialize-binary-tree.html#</span><span class="si">%E</span><span class="s2">4%BB%A3</span><span class="si">%E</span><span class="s2">7%A0%81
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">def</span> <span class="nf">Serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&#34;#&#34;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;,&#34;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Serialize</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&#34;,&#34;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Serialize</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">Deserialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flag</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flag</span><span class="p">]))</span>
            <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Deserialize</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://www.acwing.com/problem/content/46/">序列化二叉树</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="c1">// 序列化的时候使用 #表示空节点，节点和结点之间使用 ,隔开
</span><span class="c1"></span>    <span class="c1">// Encodes a tree to a single string.
</span><span class="c1"></span>    <span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">dfs_s</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">dfs_s</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s">&#34;#,&#34;</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="o">+</span><span class="sc">&#39;,&#39;</span><span class="p">;</span>
        <span class="n">dfs_s</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">dfs_s</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        
    <span class="p">}</span>
    
    

    <span class="c1">// Decodes your encoded data to tree.
</span><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs_d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        
    <span class="p">}</span>

    <span class="n">TreeNode</span><span class="o">*</span>  <span class="nf">dfs_d</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span><span class="sc">&#39;#&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">u</span> <span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        
        
        <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">is_minus</span> <span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        
        <span class="k">while</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span><span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span><span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="n">is_minus</span> <span class="o">=</span><span class="nb">true</span><span class="p">;</span>
            <span class="k">else</span> <span class="n">t</span> <span class="o">=</span><span class="n">t</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">;</span>
            <span class="n">u</span> <span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">u</span> <span class="o">++</span><span class="p">;</span> <span class="c1">// 这个本身代表的含义是  data[u] ==&#39;,&#39;， 注意这种上下文
</span><span class="c1"></span>        
        <span class="k">if</span><span class="p">(</span><span class="n">is_minus</span> <span class="p">)</span> <span class="n">t</span> <span class="o">=-</span><span class="n">t</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">root</span> <span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span> <span class="n">left</span> <span class="o">=</span><span class="n">dfs_d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span><span class="n">dfs_d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
    
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>二叉搜索树的第k个结点</li>
</ul>
<blockquote>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
</blockquote>
<p>Tips: 二叉搜索树，中序遍历之后有序，然后取第 k 个结点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">middle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">middle</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">middle</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            
    <span class="k">def</span> <span class="nf">KthNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pRoot</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="c1"># write code here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pRoot</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">middle</span><span class="p">(</span><span class="n">pRoot</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度是 $O(K)$, 这个是最优的解法了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">kthNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        
    <span class="p">}</span>
    <span class="c1">// 当你传递唯一的k 的时候，一定要保证操作的是一个数字。
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span><span class="c1">// 跳出条件
</span><span class="c1"></span>        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        
        <span class="n">k</span> <span class="o">--</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">k</span><span class="p">)</span> <span class="n">res</span> <span class="o">=</span><span class="n">root</span><span class="p">;</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">jijeng</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-06-17
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://ftp.bmp.ovh/imgs/2020/12/a67dbe80ab6832ca.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://ftp.bmp.ovh/imgs/2020/12/b575cd4858bd404d.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/resnet_understanding/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">ResNet and Inception V3 Understanding</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/bert/">
            <span class="next-text nav-default">关于BERT改进的几篇论文</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://jijeng.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>jijeng</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
