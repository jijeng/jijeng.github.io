<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode-Tree - Jijeng&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jijeng" /><meta name="description" content="刷题笔记，主题是树，以LeetCode上的题目为例。树相关的题目大多使用到递归的思想， 尤其是在深度优先遍历中；还有一类遍历方式：宽度优先遍历，使用队列来实现。
" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.79.1 with theme even" />


<link rel="canonical" href="http://jijeng.github.io/post/leetcode_tree/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Leetcode-Tree" />
<meta property="og:description" content="刷题笔记，主题是树，以LeetCode上的题目为例。树相关的题目大多使用到递归的思想， 尤其是在深度优先遍历中；还有一类遍历方式：宽度优先遍历，使用队列来实现。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jijeng.github.io/post/leetcode_tree/" />
<meta property="article:published_time" content="2019-02-20T17:57:54+08:00" />
<meta property="article:modified_time" content="2019-02-20T17:57:54+08:00" />
<meta itemprop="name" content="Leetcode-Tree">
<meta itemprop="description" content="刷题笔记，主题是树，以LeetCode上的题目为例。树相关的题目大多使用到递归的思想， 尤其是在深度优先遍历中；还有一类遍历方式：宽度优先遍历，使用队列来实现。">
<meta itemprop="datePublished" content="2019-02-20T17:57:54+08:00" />
<meta itemprop="dateModified" content="2019-02-20T17:57:54+08:00" />
<meta itemprop="wordCount" content="8481">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode-Tree"/>
<meta name="twitter:description" content="刷题笔记，主题是树，以LeetCode上的题目为例。树相关的题目大多使用到递归的思想， 尤其是在深度优先遍历中；还有一类遍历方式：宽度优先遍历，使用队列来实现。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Jijeng&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Jijeng&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Leetcode-Tree</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-02-20 </span>
        <div class="post-category">
            <a href="/categories/leetcode/"> leetcode </a>
            </div>
          <span class="more-meta"> 约 8481 字 </span>
          <span class="more-meta"> 预计阅读 17 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#nac">NAC</a></li>
        <li><a href="#medium-类型的题目">medium 类型的题目</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>刷题笔记，主题是树，以LeetCode上的题目为例。树相关的题目大多使用到递归的思想， 尤其是在深度优先遍历中；还有一类遍历方式：宽度优先遍历，使用队列来实现。</p>
<ol>
<li>** 判断是不是一个二叉搜索树？**</li>
</ol>
<p>解题思路有二。一方面是可以递归的进行判断，如果根节点大于（严格）左子树，小于右子树。那么是一个二叉搜索树。另一方可以使用区间的思想。就是下面的解法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 判断是否是二叉搜索树， 左子树&lt; 根节点&lt; 右子树
</span><span class="c1"></span>    <span class="c1">// 使用区间的概念，根节点 [INT_MIN, INT_MAX]
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isValidBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>   
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">minv</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxv</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">minv</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">maxv</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">minv</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">-</span> <span class="mi">1ll</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">+</span><span class="mi">1ll</span><span class="p">,</span> <span class="n">maxv</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>** Binary Tree Inorder Traversal**</li>
</ol>
<p>中序非递归遍历。</p>
<p>a. 将整个树的最左边一条链压入栈中
b. 每次取出栈顶元素，如果有右子树，那么将右子树压入栈中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">root</span><span class="p">;</span>
        <span class="c1">// 这个条件也是比较nice的， p || stk.size() 
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span> <span class="n">p</span> <span class="o">||</span> <span class="n">stk</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span> <span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 这个p 是一个遍历指针，类似i，是可以重复的赋值的
</span><span class="c1"></span>            <span class="n">p</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">//auto tmp =stk.top();
</span><span class="c1"></span>            <span class="c1">//stk.pop();
</span><span class="c1"></span>            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span> <span class="n">val</span><span class="p">);</span>
            <span class="c1">// 然后就转向了右子树
</span><span class="c1"></span>            <span class="n">p</span> <span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>   
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Symmetric Tree</li>
</ol>
<p>递归判断是否是 symmetric tree。 这个还是非常nice的。 这种思路比较简单的，根节点不用比较，然后左右子树，左子树的左结点和右子树的右节点，左子树的右节点和右子树的左结点。</p>
<p>a. 两个根节点的值要相等
b. 左边的左子树和右边的右子树对称
c. 左边的右子树和右边的左子树对称</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    // 对称， 左子树的左结点 和右子树的右节点； 左子树的右节点和右子树的左结点
    // 
    bool isSymmetric(TreeNode* root) {
        // 如果为空 那么 return true
        if (! root) return true;
        return dfs(root-&gt; left, root -&gt; right);
    }
    bool dfs(TreeNode * left, TreeNode * right)
    {
        if(! left || ! right) return !left &amp;&amp; ! right; // 只有两者都为空，那么才是true
        if(left-&gt; val != right -&gt; val) 
            return false;
        return dfs(left-&gt; left, right -&gt; right) &amp;&amp; dfs(left-&gt; right, right  -&gt; left);
    }
};
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>重建二叉树</li>
</ol>
<p>根据前序遍历和中序遍历重塑二叉树。
在一个无序的list 中去查找二叉树，时间是 $O(n)$，这个是可以使用hash 优化成 $O(1)$。重点是可以通过长度进行划分 左子树序列和右子树序列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">buildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">inorder</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span><span class="n">preorder</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">hash</span><span class="p">[</span><span class="n">inorder</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">TreeNode</span> <span class="o">*</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">preorder</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">inorder</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">il</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ir</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// dfs 一定是有return 的
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">pl</span> <span class="o">&gt;</span> <span class="n">pr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span> <span class="p">;</span>
        
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span><span class="n">preorder</span><span class="p">[</span><span class="n">pl</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">index</span>  <span class="o">=</span><span class="n">hash</span><span class="p">[</span><span class="n">val</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span><span class="n">index</span> <span class="o">-</span><span class="n">il</span><span class="p">;</span>
        <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">pl</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">pl</span> <span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="n">il</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">,</span> <span class="n">pl</span><span class="o">+</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ir</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>层序遍历，非递归写法。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 层次遍历，先进先出，队列的东西
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">levelOrder</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">level</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="c1">// 这个是需要划分成一层的
</span><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
                <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="n">level</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">val</span> <span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">level</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>lowest common ancestor of a binary tree</li>
</ol>
<p>二叉树的最小公共父节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 最短公共祖先
</span><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span><span class="n">root</span> <span class="o">||</span> <span class="n">q</span> <span class="o">==</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="c1">// 否则就需要进行寻找
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">left</span> <span class="o">=</span><span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">right</span> <span class="o">=</span><span class="n">lowestCommonAncestor</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">left</span><span class="p">)</span> <span class="k">return</span> <span class="n">right</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>serialize and deserialize binary tree</li>
</ol>
<p>一般来说，单独的前序遍历是不能唯一确定一个树的结构。（使用前序遍历和中序遍历才能确定一个二叉树的结构，如之前的题目）但是这里可以唯一确定，因为前序遍历中把空节点加入了整个序列中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Codec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 编码的格式 1,2,#,#,
</span><span class="c1"></span>    
    <span class="c1">// Encodes a tree to a single string.
</span><span class="c1"></span>    <span class="c1">// 使用string 的地址表示 exactly 的那种结果
</span><span class="c1"></span>    <span class="n">string</span> <span class="n">serialize</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">dfs1</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">dfs1</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span><span class="s">&#34;#,&#34;</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span><span class="o">+</span><span class="sc">&#39;,&#39;</span><span class="p">;</span>
        <span class="n">dfs1</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
        <span class="n">dfs1</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Decodes your encoded data to tree.
</span><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span>
        <span class="k">return</span> <span class="n">dfs2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>   
    <span class="p">}</span>
    
    
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">dfs2</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">u</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span><span class="sc">&#39;#&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">u</span> <span class="o">+=</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// 一个 # 一个,
</span><span class="c1"></span>            <span class="k">return</span> <span class="nb">NULL</span> <span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="n">is_minus</span> <span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span><span class="sc">&#39;-&#39;</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">is_minus</span> <span class="o">=</span><span class="nb">true</span><span class="p">;</span>
            <span class="n">u</span> <span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span><span class="mi">10</span> <span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">;</span>
            <span class="n">u</span> <span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">u</span> <span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">is_minus</span><span class="p">)</span> <span class="n">val</span> <span class="o">=-</span><span class="n">val</span><span class="p">;</span>
        <span class="k">auto</span>  <span class="n">root</span> <span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span><span class="n">dfs2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span><span class="n">dfs2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Your Codec object will be instantiated and called as such:
</span><span class="c1">// Codec codec;
</span><span class="c1">// codec.deserialize(codec.serialize(root));
</span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>diameter of binary tree</li>
</ol>
<p>先是枚举节点，然后求解左右子树深度之和。因为左右子树是没有联系的，是可以单独求解左右子树的最大深度。（ 和下一道题目相比，这个所有的权重都是 1) 时间复杂度是 $O(n)$， 因为这个一定是从根节点出发 的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 这个题目和最长路径不一样，在于这个是求解边的长度，而不是结点的个数
</span><span class="c1"></span>    <span class="c1">// 所以最长的是一定是从根节点出发的， 然后dfs进行
</span><span class="c1"></span>    <span class="c1">// 长度是  left + right
</span><span class="c1"></span>    <span class="c1">// 时间复杂度是 O(n)
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">diameterOfBinaryTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 这个不是dfs ，这个是从root向下走的最大的路径
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">auto</span>  <span class="n">left</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
        <span class="k">auto</span>  <span class="n">right</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span><span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="9">
<li>binary tree maximum path sum</li>
</ol>
<p>这个权重有正有负。时间复杂度是 $O( n^2)$， 首先枚举的是点 $O(n)$ ，然后每个点上计算， 那么也是 $O(n)$， 最后的结果是 $O(n ^2)$。
这里实际上是有三种路径的：
a. root -&gt; val + L
b. root-&gt;val + R
c. root -&gt;val</p>
<p>所以看一下最后是三种选择的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="o">/**</span>
 <span class="o">*</span> <span class="n">Definition</span> <span class="k">for</span> <span class="n">a</span> <span class="n">binary</span> <span class="n">tree</span> <span class="n">node</span><span class="o">.</span>
 <span class="o">*</span> <span class="n">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
 <span class="o">*</span>     <span class="nb">int</span> <span class="n">val</span><span class="p">;</span>
 <span class="o">*</span>     <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
 <span class="o">*</span>     <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
 <span class="o">*</span>     <span class="n">TreeNode</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">NULL</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">NULL</span><span class="p">)</span> <span class="p">{}</span>
 <span class="o">*</span> <span class="p">};</span>
 <span class="o">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
    <span class="o">//</span> <span class="err">权重可以看成</span> <span class="n">root</span> <span class="o">-&gt;</span><span class="n">val</span>
    <span class="nb">int</span> <span class="n">res</span> <span class="o">=</span><span class="n">INT_MIN</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">maxPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>   
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="err">从根节点遍历</span>
    <span class="nb">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="err">!</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="o">//</span> <span class="err">左右子树的最大值</span>
        <span class="nb">int</span> <span class="n">left</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
        <span class="nb">int</span> <span class="n">right</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span><span class="n">right</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="o">//</span> <span class="err">返回当前节点的最大值</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">173. Binary Search Tree Iterator</a></p>
<p>其中的 average 是均摊的意思， $O(n) $ 除以 $n$ 那么最后的结果是 $O(1)$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode:</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>

<span class="k">class</span> <span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="c1"># 使用过栈 模拟中序遍历的过程， next 表示栈顶元素</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stk</span> <span class="o">=</span><span class="p">[]</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span><span class="n">root</span><span class="o">.</span><span class="n">left</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        @return the next smallest number
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="n">popp</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stk</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">root</span> <span class="o">=</span><span class="n">popp</span><span class="o">.</span><span class="n">right</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">return</span> <span class="n">popp</span><span class="o">.</span><span class="n">val</span>
        

    <span class="k">def</span> <span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        @return whether we have a next smallest number
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stk</span>

<span class="c1"># Your BSTIterator object will be instantiated and called as such:</span>
<span class="c1"># obj = BSTIterator(root)</span>
<span class="c1"># param_1 = obj.next()</span>
<span class="c1"># param_2 = obj.hasNext()</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/complete-binary-tree-inserter/">919. Complete Binary Tree Inserter</a></p>
<p>使用了完全二叉树中根节点和叶子节点的性质。空间复杂度是$O(n)$，insert 的时间复杂度是$O(1)$，但是建立层次遍历的结果是$O(n)$，所以总的时间复杂度是$O(n)$。
（注意和下文中的c++实现的对比）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Definition for a binary tree node.</span>
<span class="c1"># class TreeNode(object):</span>
<span class="c1">#     def __init__(self, x):</span>
<span class="c1">#         self.val = x</span>
<span class="c1">#         self.left = None</span>
<span class="c1">#         self.right = None</span>

<span class="k">class</span> <span class="nc">CBTInserter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        :type root: TreeNode
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rootnode</span> <span class="o">=</span><span class="n">root</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="c1">#初始化一个节点，使根节点从数组中序号为1 开始</span>
        <span class="c1"># 队列一般是bfs，这里得到是一个层次遍历的结果</span>
        <span class="n">q</span> <span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">left</span> <span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        :type v: int
</span><span class="s2">        :rtype: int
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="n">node</span> <span class="o">=</span><span class="n">TreeNode</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">//</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span><span class="n">node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span><span class="n">node</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
    
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        :rtype: TreeNode
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootnode</span>
        
<span class="c1"># Your CBTInserter object will be instantiated and called as such:</span>
<span class="c1"># obj = CBTInserter(root)</span>
<span class="c1"># param_1 = obj.insert(v)</span>
<span class="c1"># param_2 = obj.get_root()</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/complete-binary-tree-inserter/">919. Complete Binary Tree Inserter</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="c1">// 首先是对于complete tree 的定义，完全二叉树是 和数字序号一一对应。大根堆和小根堆也是一种完全二叉树，当前的i 和左子树是 2*i， 右子树是 (2*i+1)的性质
</span><span class="c1"></span><span class="k">class</span> <span class="nc">CBTInserter</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">CBTInserter</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span><span class="n">root</span><span class="p">;</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">new_node</span> <span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span><span class="n">new_node</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span><span class="n">new_node</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// 只有末尾两行的结点是可以当做父节点的存在，其他的是不太可能的；
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">get_root</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**
</span><span class="cm"> * Your CBTInserter object will be instantiated and called as such:
</span><span class="cm"> * CBTInserter* obj = new CBTInserter(root);
</span><span class="cm"> * int param_1 = obj-&gt;insert(v);
</span><span class="cm"> * TreeNode* param_2 = obj-&gt;get_root();
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="">二叉搜索树的第k个结点</a></p>
<p>来自剑指offer。二叉搜索树就是二叉排序树。中序遍历是先左子树，根节点，最后是右子树，提供两种写法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">kthNode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="cp"># 这里可能最重要是使用引用而非值传递
</span><span class="cp"></span>    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="n">k</span> <span class="o">-=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">k</span><span class="p">)</span> <span class="n">res</span> <span class="o">=</span><span class="n">root</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></p>
<p>先序遍历，先是根节点，然后是左右子树，时间复杂度是$O(n)$。（ 这种做法有点类似层序遍历呀）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">ans</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">counter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span><span class="n">level</span><span class="p">)</span> <span class="err">#</span> <span class="err">这个语句很好的处理，</span><span class="n">c</span><span class="o">++</span> <span class="err">中</span><span class="n">index</span> <span class="err">访问的问题。</span>
        <span class="p">{</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="n">counter</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">++</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">level</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">averageOfLevels</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">;</span>
        
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
        
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/merge-two-binary-trees/">LeetCode 617. Merge Two Binary Trees </a></p>
<p>递归的做法。从根节点开始， 分成四种情况，如果两树$t_1$， $t_2$都为空，那么返回为空； 如果$t_1$为空，那么返回$t_2$；如果$t_2$为空，那么返回$t_1$；否则分别递归的左右子树。
因为每个结点最多遍历一次，所以时间复杂度是$O(m+n)$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 如果对于递归不是很了解，那么就适合去做 树相关的习
</span><span class="c1"></span>    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">t1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">t2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">t1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t2</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">t1</span> <span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">t2</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">t1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">t1</span><span class="p">;</span>      
        <span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">=</span><span class="n">mergeTrees</span><span class="p">(</span><span class="n">t1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
        <span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">=</span><span class="n">mergeTrees</span><span class="p">(</span><span class="n">t1</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">t1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/">LeetCode 606. Construct String from Binary Tree </a></p>
<p>需要注意的是，如果只有在左孩子，无序添加一对括号，如果只有右孩子，那么需要添加一对括号，表示两者之间的一一对应的关系。时间复杂度是$O(n)$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> int val;
</span><span class="cm"> TreeNode * left;
</span><span class="cm"> TreeNode * right;
</span><span class="cm"> TreeNode(int x): val(x), left(nullptr), right(nullptr) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">string</span> <span class="nf">tree2str</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">ans</span> <span class="o">=</span><span class="s">&#34;&#34;</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/construct-string-from-binary-tree/">606. Construct String from Binary Tree</a></p>
<p>需要注意的是，如果只有在左孩子，无序添加一对括号，如果只有右孩子，那么需要添加一对括号，表示两者之间的一一对应的关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> int val;
</span><span class="cm"> TreeNode * left;
</span><span class="cm"> TreeNode * right;
</span><span class="cm"> TreeNode(int x): val(x), left(nullptr), right(nullptr) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">to_string</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">string</span> <span class="nf">tree2str</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">ans</span> <span class="o">=</span><span class="s">&#34;&#34;</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/subtree-of-another-tree/">572. Subtree of Another Tree</a></p>
<p>时间复杂度是$O(mn)$，对于大树 $s$中的每个结点，都是需要在小树 $t$中遍历一遍，所以是两者个数的相乘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">isSame</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">||</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="nf">isSame</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">||</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">t</span> <span class="o">||</span> <span class="n">s</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span> <span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">isSame</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">t</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSame</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="kt">bool</span> <span class="nf">isSubtree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/binary-tree-tilt/">LeetCode 563. Binary Tree Tilt </a></p>
<p>看着比较高大上，实际上就是树的遍历问题，可以使用深度遍历的方式。深度优先遍历，时间复杂度是$O(n)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ls</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rs</span> <span class="o">=</span><span class="n">dfs</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">ls</span> <span class="o">-</span><span class="n">rs</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ls</span> <span class="o">+</span><span class="n">rs</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">findTilt</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 这个是二叉搜索树，左子树小于根节点，根节点小于右子树
</span><span class="c1"></span>    <span class="c1">// 要求求解累加树，是一个逆中序遍历 （右中左）
</span><span class="c1"></span>    <span class="c1">// 中序遍历（左子树 根节点 右子树）
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// sum 表示一种累加和
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">+=</span><span class="n">sum</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">convertBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/submissions/">530. Minimum Absolute Difference in BST</a></p>
<p>需要使用额外的变量 存储上一个结点；大多数的问题都是树的遍历求解问题；如果限定是二叉搜素树，那么很大的可能是中序遍历（因为只有中序遍历结果是递增有序的，所以是很好的性质）</p>
<p>（之前所有的题目都是这样的，都是假设栈的开销不被计算在内，这样才能够分析空间复杂度）
假设由递归产生的隐式调用栈的开销不被计算在内</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ans</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>   
        <span class="k">if</span><span class="p">(</span><span class="n">last</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ans</span> <span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">r</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">-</span><span class="n">last</span><span class="p">);</span>
        <span class="n">last</span> <span class="o">=</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span><span class="n">INT_MAX</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a></p>
<p>自顶向下，没经过一个结点，sum减去该结点的数值，只有两条路径，要么是从 left 走，要么是从right 走，最后判断是否满足条件。每个节点仅被遍历一次，时间复杂度是$O(n)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>      
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="k">return</span>  <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">==</span> <span class="n">sum</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">sum</span> <span class="o">-</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="p">,</span> <span class="n">sum</span> <span class="o">-</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/path-sum-ii/">113. Path Sum II</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 上一个题目判断是否存在这样的路径，这个题目是返回这样符合条件的路径。
</span><span class="c1"></span>    <span class="c1">// 时间复杂度，因为判断是否存在，只是需要找到一条路径即可；而找到所有的路径需要的时间复杂度是$O(n^2)$
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">sum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">||</span> <span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
            <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sum</span><span class="p">)</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></p>
<p>（这个数字是非常的吉利呀）， 使用 left 来标识是否是左右子树，非常的nice。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="n">sum</span>  <span class="o">+=</span> <span class="n">root</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/cousins-in-binary-tree/">993. Cousins in Binary Tree</a></p>
<p>通过树的遍历，分别找到 <code>x</code> 和 <code>y</code> 的深度和对应的父节点，可以采用深度优先或者宽度优先的方式。时间复杂度是$O(n)$， 如果是深度优先遍历，那么是需要$O(h)$的栈空间，如果是宽度优先遍历，需要$O(n)$ 的队列空间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">fa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">==</span><span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">d</span> <span class="o">=</span><span class="n">depth</span><span class="p">;</span>
            <span class="n">f</span> <span class="o">=</span><span class="n">fa</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">rt</span> <span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">isCousins</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">dx</span> <span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">fx</span><span class="p">,</span> <span class="o">*</span><span class="n">fy</span><span class="p">;</span>
        <span class="c1">// 总的思路还是分别求解出 x y 的深度和头结点
</span><span class="c1"></span>        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">fx</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">fy</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dx</span> <span class="o">!=</span> <span class="n">dy</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">fx</span> <span class="o">!=</span> <span class="n">fy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/univalued-binary-tree/">965. Univalued Binary Tree</a></p>
<p>这个题目判断树中的值是否全部都是一样的，就是树的遍历问题，可以使用深度优先或者宽度优先。时间复杂度是$O(n)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">check</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">check</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">check</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">isUnivalTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 判断是否具有唯一值,
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">check</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">LeetCode 559. Maximum Depth of N-ary Tree </a></p>
<p>对于n 叉树的遍历，返回其最大的深度。时间复杂度是$O(n)$。对于树的题目，除了比较经典的二叉树结构之外，还需要掌握多叉树的结构。二叉搜索树的相关题目也是很多呀。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">// Definition for a Node.
</span><span class="cm">class Node {
</span><span class="cm">public:
</span><span class="cm">    int val;
</span><span class="cm">    vector&lt;Node*&gt; children;
</span><span class="cm">    Node() {}
</span><span class="cm">    Node(int _val) {
</span><span class="cm">        val = _val;
</span><span class="cm">    }
</span><span class="cm">    Node(int _val, vector&lt;Node*&gt; _children) {
</span><span class="cm">        val = _val;
</span><span class="cm">        children = _children;
</span><span class="cm">    }
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 就是在叶子结点中最大的深度
</span><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">r</span> <span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dfs</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/trim-a-binary-search-tree/">LeetCode 669. Trim a Binary Search Tree </a></p>
<p>递归在逻辑上是比较简单的，二叉搜索树因为具有排序的性质，所以是经常的考点。时间复杂度是$O(n)$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">=</span> <span class="n">trimBST</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/">1305. All Elements in Two Binary Search Trees</a></p>
<p>时间复杂度$O(m +n)$， 空间复杂度： 递归的系统栈最坏情况下需要$O(m+n)$空间，中间的数组也是$O(m+n)$，所以总的空间复杂度是$O(m +n)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 这个思路很简单
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">traverse</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
        <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getAllElements</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span>
        <span class="n">traverse</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="c1">// 这种写法 非常的nice，将归并的做法合在了一起
</span><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span><span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span><span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
                <span class="k">else</span> 
                    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="nac">NAC</h2>
<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">LeetCode 501. Find Mode in Binary Search Tree </a></p>
<p>在遍历的过程中，加上一个统计工作，之前在数组中找众数也是这个逻辑，只不过遍历的方式不一样了。</p>
<p>在分析空间复杂度的时候，<code>除了记录答案的额数组和递归使用的系统栈外，其余只使用了常数的内存空间</code> 这样的描述是相当的精确。</p>
<p>题目中对于BST 进行了重新的定义，小于等于也是算作左子树。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">ans</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">last_num</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">num_count</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ans_count</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">last_num</span><span class="p">,</span> <span class="n">num_count</span><span class="p">,</span> <span class="n">ans_count</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">last_num</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num_count</span> <span class="o">&gt;</span> <span class="n">ans_count</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ans_count</span> <span class="o">=</span> <span class="n">num_count</span><span class="p">;</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">last_num</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">num_count</span> <span class="o">==</span> <span class="n">ans_count</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">last_num</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">last_num</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">num_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">num_count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">last_num</span><span class="p">,</span> <span class="n">num_count</span><span class="p">,</span> <span class="n">ans_count</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findMode</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">last_num</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">last_num</span><span class="p">,</span> <span class="n">num_count</span><span class="p">,</span> <span class="n">ans_count</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">num_count</span> <span class="o">&gt;</span> <span class="n">ans_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans_count</span> <span class="o">=</span> <span class="n">num_count</span><span class="p">;</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">last_num</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">num_count</span> <span class="o">==</span> <span class="n">ans_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">last_num</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/range-sum-of-bst/">938. Range Sum of BST</a></p>
<p>通过二叉搜索树 的性质判断 某个结点是否在左右子树之间。递归遍历，时间复杂度是$O(n)$，空间复杂度有一个系统的栈空间$o(k)$，除此之外是$O(1)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">rt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ans</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">rt</span> <span class="p">)</span> <span class="k">return</span> <span class="p">;</span>   
        <span class="k">if</span><span class="p">(</span><span class="n">L</span> <span class="o">&lt;=</span> <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">)</span> 
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span> <span class="o">&lt;</span> <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">rangeSumBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/">671. Second Minimum Node In a Binary Tree</a></p>
<p>寻找第二小的值，由题目知道根节点的数字是最小的，那么就需要递归寻找其左右子树中最小的树，注意只有当前节点的值和根节点的值相等的情况下，才可能进行递归。</p>
<p>···c++
/**</p>
<ul>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li>};
*/
class Solution {
public:
void find(TreeNode <em>r, int minr, int &amp;ans)
{
if(!r) return ;
if(r-&gt;val != minr )
{
if(ans ==-1)
ans = r -&gt;val;
else
ans = min(ans, r -&gt;val);
return ;
}
// 进行dfs 操作的是这里，如果和根节点相同的话，那么就递归其左右子树了
find(r -&gt;left, minr, ans);
find(r-&gt;right, minr , ans);
}
int findSecondMinimumValue(TreeNode</em> root) {
int ans =-1;
find(root, root-&gt;val, ans);
return ans;
}
};
···</li>
</ul>
<p><a href="https://leetcode.com/problems/leaf-similar-trees/">872. Leaf-Similar Trees</a></p>
<p>不管是dfs 还是bfs，每个节点都是要遍历的，只是在选择的是不一样；时间复杂度分析，需要遍历两颗树的节点，时间复杂度是$O(n)$。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">path</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span> <span class="n">root</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 这个就是遍历叶子节点
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">leafSimilar</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span><span class="o">*</span> <span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seq1</span><span class="p">,</span> <span class="n">seq2</span><span class="p">;</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span> <span class="n">seq1</span><span class="p">);</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root2</span><span class="p">,</span> <span class="n">seq2</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">seq1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">seq2</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">seq1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="n">seq1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">seq2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>Postorder 后序遍历，后根遍历。</p>
<p><a href="https://leetcode.com/problems/n-ary-tree-postorder-traversal/">590. N-ary Tree Postorder Traversal</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">// Definition for a Node.
</span><span class="cm">class Node {
</span><span class="cm">public:
</span><span class="cm">    int val;
</span><span class="cm">    vector&lt;Node*&gt; children;
</span><span class="cm">    Node() {}
</span><span class="cm">    Node(int _val) {
</span><span class="cm">        val = _val;
</span><span class="cm">    }
</span><span class="cm">    Node(int _val, vector&lt;Node*&gt; _children) {
</span><span class="cm">        val = _val;
</span><span class="cm">        children = _children;
</span><span class="cm">    }
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// 迭代法后序遍历， n叉树
</span><span class="c1"></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">postorder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>        
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span> <span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">st</span><span class="p">;</span>
        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="p">.</span><span class="n">first</span> <span class="o">-&gt;</span>  <span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span><span class="mi">1</span><span class="p">));</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">second</span><span class="p">],</span> <span class="mi">0</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="k">else</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">589. N-ary Tree Preorder Traversal</a></p>
<p>要求使用迭代法实现树的遍历，使用栈的数据结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/*
</span><span class="cm">// Definition for a Node.
</span><span class="cm">class Node {
</span><span class="cm">public:
</span><span class="cm">    int val;
</span><span class="cm">    vector&lt;Node*&gt; children;
</span><span class="cm">    Node() {}
</span><span class="cm">    Node(int _val) {
</span><span class="cm">        val = _val;
</span><span class="cm">    }
</span><span class="cm">    Node(int _val, vector&lt;Node*&gt; _children) {
</span><span class="cm">        val = _val;
</span><span class="cm">        children = _children;
</span><span class="cm">    }
</span><span class="cm">};
</span><span class="cm">*/</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">preorder</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">st</span><span class="p">;</span>
        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span> <span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>    
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="p">.</span><span class="n">first</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span><span class="mi">1</span><span class="p">));</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span> <span class="o">-&gt;</span> <span class="n">children</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">second</span><span class="p">],</span> <span class="mi">0</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/increasing-order-search-tree/">897. Increasing Order Search Tree</a></p>
<p>时间复杂度是$O(n)$， 需要系统提供栈空间，大小为树的深度，故空间复杂度是$O(H)$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="n">solve</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span> <span class="o">&amp;</span><span class="n">rt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span><span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span><span class="k">nullptr</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">rt</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span><span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>   
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right_most</span> <span class="o">=</span><span class="n">solve</span><span class="p">(</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">left</span> <span class="o">=</span><span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="n">right_most</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">=</span><span class="n">rt</span><span class="p">;</span>
        <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">rt</span> <span class="o">=</span><span class="n">left</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">solve</span><span class="p">(</span><span class="n">right_most</span> <span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">increasingBST</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">solve</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>      
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="medium-类型的题目">medium 类型的题目</h2>
<p><a href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></p>
<p>选择当前list 中的最大值为根节点，然后左边的为左子树；右边为右子树; 递归进行。时间复杂度，当数组是有序的，那么每次分别需要 n n-1 n-2 &hellip; 1 次数进行计算， 所以最后的时间复杂度是$O(n^2)$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * struct TreeNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     TreeNode *left;
</span><span class="cm"> *     TreeNode *right;
</span><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">build</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">&gt;</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">max_num</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">max_i</span> <span class="o">=</span><span class="n">l</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="n">l</span> <span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">max_num</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">max_num</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">max_i</span> <span class="o">=</span><span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rt</span> <span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">max_num</span><span class="p">);</span>
        <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">max_i</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">rt</span> <span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span><span class="n">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">max_i</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rt</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>   
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></p>
<p>动态规划 时间复杂度$O(n^2)$， $f[n]$ 表示 $n$个节点的二叉搜索树共有多少种。状态转移表示为如下形式：</p>
<p>\begin{equation}
f[n]=\sum_{k=0}^{n-1} f[k] * f[n-1-k]
\end{equation}</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">numTrees</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">jijeng</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-02-20
        
    </span>
  </p>
  
  
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://ftp.bmp.ovh/imgs/2020/12/a67dbe80ab6832ca.png">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://ftp.bmp.ovh/imgs/2020/12/b575cd4858bd404d.png">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/python_path/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Python 中Path相关的处理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/linux_tutorial_1/">
            <span class="next-text nav-default">Linux Tutorial (1)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://jijeng.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>jijeng</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
